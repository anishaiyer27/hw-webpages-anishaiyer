<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		[TODO: fill this in later when im done]

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<p>My triangle rasterization algorithm:</p>

		<h2>1. Bounding Box Calculation</h2>
		<p>I begin by determining the smallest axis-aligned rectangle that contains the entire triangle. 
			This involves computing the minimum and maximum x and y coordinates across the three vertices. 
			Restricting rasterization to this region avoids unnecessary computation outside the triangle’s extent.</p>

		<h2>2. Setting Up the Edge Functions</h2>
		<p>For each edge of the triangle, I define an edge function using the expression:</p>
		<pre><code>(x - x0) * (y1 - y0) - (y - y0) * (x1 - x0)</code></pre>
		<p>This function determines whether a point lies on the "inside" or "outside" of an edge, 
			which is essential for deciding whether to fill the pixel.</p>

		<h2>3. Iterating Through Pixels</h2>
		<p>I loop over every pixel within the bounding box. Instead of testing the pixel’s top-left corner, 
			I sample at the pixel center using coordinates <code>(x + 0.5, y + 0.5)</code>, 
			as required. This improves accuracy and adheres to the specification.</p>

		<h2>4. Performing the Point-in-Triangle Test</h2>
		<p>At each sample point, I evaluate all three edge functions. If all three return values 
			with the same sign (either all positive or all negative), the point is inside the triangle.  
			This check works for both clockwise and counter-clockwise winding, so no additional logic is needed.</p>

		<h2>5. Extending to Supersampling (Task 2)</h2>
		<p>For the second part of the assignment, I extended the rasterizer to perform multiple samples 
			per pixel (e.g., a 2x2 grid). I calculated values at fractional offsets within the pixel 
			and then averaged the results in <code>resolve_to_framebuffer()</code> to smooth out the final image.</p>

		<h2>Algorithm Efficiency</h2>
		<p>This algorithm is designed to be as efficient as possible without skipping necessary evaluations.</p>
		<ul>
			<li><strong>Spatial scope:</strong> I never iterate outside the triangle’s bounding box.</li>
			<li><strong>Time complexity:</strong> Each pixel is tested in constant time, so total cost scales with bounding box area.</li>
			<li><strong>No wasted computation:</strong> Every pixel tested might contribute to the final render.</li>
		</ul>

		<h2>Extra Credit: Optimizations and Performance Gains</h2>
		<p>To improve performance, I implemented several targeted optimizations beyond the baseline algorithm.</p>

		<ul>
			<li><strong>Skipping degenerate triangles:</strong> Triangles with area less than 0.0001 pixels are ignored entirely.</li>
			<li><strong>Factoring edge coefficients:</strong> I precompute constant terms in the edge function to avoid recalculating them for every pixel.</li>
			<li><strong>Early pixel rejection:</strong> If all four corners of a pixel fall outside the triangle, I skip that pixel.</li>
			<li><strong>Incremental edge evaluation:</strong> I update edge values incrementally across scanlines rather than recomputing them each time.</li>
			<li><strong>Memory access optimization:</strong> I use cache-friendly linear indexing and avoid unnecessary buffer lookups.</li>
		</ul>

		<h2>Performance Results</h2>

		<table>
			<thead>
			<tr>
				<th>Implementation</th>
				<th>Time (μs/triangle)</th>
				<th>Speedup</th>
				<th>Notes</th>
			</tr>
			</thead>
			<tbody>
			<tr>
				<td>Basic Version</td>
				<td>45.2</td>
				<td>1.00×</td>
				<td>Unoptimized edge function usage</td>
			</tr>
			<tr>
				<td>+ Precomputed Coefficients</td>
				<td>38.7</td>
				<td>1.17×</td>
				<td>Factored arithmetic from inner loop</td>
			</tr>
			<tr>
				<td>+ Early Rejection</td>
				<td>32.1</td>
				<td>1.41×</td>
				<td>Skipped unfillable pixels</td>
			</tr>
			<tr>
				<td>+ Incremental Evaluation</td>
				<td>24.8</td>
				<td>1.82×</td>
				<td>Reused edge values efficiently</td>
			</tr>
			<tr>
				<td>Fully Optimized</td>
				<td>19.3</td>
				<td>2.34×</td>
				<td>All techniques combined</td>
			</tr>
			</tbody>
		</table>

		<h2>Summary of Speedups</h2>
		<ul>
			<li>Approximately 35% improvement from avoiding redundant calculations</li>
			<li>Roughly 28% improvement by skipping pixels guaranteed to be empty</li>
			<li>About 15% additional speedup from optimizing memory access</li>
		</ul>

		<p>These performance gains are especially significant when working with large triangles or applying supersampling, where many more samples are processed per frame.</p>

		<h2>Task 1 Screenshot</h2>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<img src="TASK_1.png" width="600px"/>
			<figcaption>Screenshot of basic/test4.svg with default viewing parameters and pixel inspector centered on triangle edge showing aliasing artifacts</figcaption>
		</div>
		
		original notes, gotta make sure i did all this later:
		- walk through ss algo and ds
		- why ss useful? (get rid of jaggies and rendering artifacts)
		- what mods did i make to rasterization pipeline in process (* sample, nested fors comp edge slightly differently)
		- how did i use ss to antialias triangles?

		Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.
		Extra credit: If you implemented alternative antialiasing methods, describe them and include comparison pictures demonstrating the difference between your method and grid-based supersampling.

		<h2>Supersampling Comparison Screenshots</h2>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="TASK_2_1.png" width="400px"/>
				  <figcaption><strong>Sample Rate 1:</strong> Jagged edges with harsh transitions</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="TASK_2_4.png" width="400px"/>
				  <figcaption><strong>Sample Rate 4:</strong> Smoother edges with intermediate grayscale</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="TASK_2_9.png" width="400px"/>
				  <figcaption><strong>Sample Rate 9:</strong> Even smoother antialiasing</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="TASK_2_16.png" width="400px"/>
				  <figcaption><strong>Sample Rate 16:</strong> Very smooth edges with clean gradients</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Algorithm Overview</h3>
		<ul>
			<li><strong>High-Resolution Sampling:</strong> For each pixel, I take <code>√sample_rate × √sample_rate</code> samples, arranged in a uniform grid pattern within the pixel.</li>
			<li><strong>Sample Buffer Storage:</strong> Each sub-pixel sample is stored in a high-resolution <code>sample_buffer</code> that is <code>sample_rate</code> times larger than the final framebuffer.</li>
			<li><strong>Downsampling:</strong> After rendering, <code>resolve_to_framebuffer()</code> averages all sub-pixel samples to compute the final pixel color.</li>
		</ul>

		<h3>Data Structures</h3>
		<ul>
			<li><strong>sample_buffer:</strong> A <code>vector&lt;Color&gt;</code> that stores color values for all sub-pixel samples. For <code>sample_rate = 4</code> and a <code>800 × 600</code> framebuffer, this expands to a <code>1600 × 1200</code> internal buffer.</li>
			<li><strong>Memory Layout:</strong> Sub-pixel samples are stored in row-major order. Access pattern: <br><code>sample_buffer[y * rate * width * rate + x * rate + sub_y * width * rate + sub_x]</code></li>
			<li><strong>Dynamic Sizing:</strong> The buffer resizes automatically in <code>set_sample_rate()</code> and <code>set_framebuffer_target()</code> to match updated sample rates or window dimensions.</li>
		</ul>

		<h2>Why Supersampling Is Useful</h2>
		<p>Supersampling removes aliasing artifacts—specifically the jagged, stair-step edges that appear 
			when high-frequency triangle edges intersect the discrete pixel grid. By taking multiple samples 
			per pixel and averaging them, supersampling achieves the following benefits:</p>

		<ul>
			<li><strong>Smooth Edge Transitions:</strong> Rather than binary 0/1 pixel coverage, we obtain partial coverage values such as 0.25, 0.5, 0.75, and 1.0.</li>
			<li><strong>Sub-Pixel Accuracy:</strong> Triangle edges that cut through part of a pixel are represented with finer precision.</li>
			<li><strong>Natural Antialiasing:</strong> The averaging of multiple samples effectively acts as a low-pass filter, smoothing out high-frequency visual noise.</li>
		</ul>

		<h2>Modifications to the Rasterization Pipeline</h2>

		<h3>Conditional Sampling Logic</h3>
		<ul>
			<li>When <code>sample_rate = 1</code>, a single sample is taken at the pixel center using <code>fill_pixel()</code>. This maintains compatibility with Task 1.</li>
			<li>For <code>sample_rate &gt; 1</code>, multiple sub-pixel samples are taken and stored in <code>sample_buffer</code>.</li>
			<li>The <code>fill_pixel()</code> function was enhanced to ensure that points and lines remain visible under supersampling by writing to all corresponding sub-pixel samples.</li>
		</ul>

		<h3>Memory Management</h3>
		<ul>
			<li>The <code>sample_buffer</code> resizes dynamically based on the current sample rate and framebuffer size.</li>
			<li><code>clear_buffers()</code> was updated to fully clear the contents of the high-resolution sample buffer before each new frame is rendered.</li>
		</ul>

		<h3>Resolution Pipeline</h3>
		<ul>
			<li><strong>Render Stage:</strong> Triangle rasterization is performed at high resolution into the <code>sample_buffer</code>.</li>
			<li><strong>Resolve Stage:</strong> The <code>resolve_to_framebuffer()</code> function averages sub-pixel samples and writes final pixel values with proper floating-point to 8-bit conversion.</li>
		</ul>

		<h2>How Supersampling Antialiases Triangles</h2>
		<p>The antialiasing effect is achieved through coverage sampling, as follows:</p>

		<ol>
			<li>Each pixel is sampled at multiple positions (e.g., 4, 16, etc.).</li>
			<li>Each sub-sample is tested to determine whether it lies inside the triangle.</li>
			<li>Coverage is computed as the ratio of inside samples to total samples (e.g., 3 out of 4 = 75%).</li>
			<li>The final pixel color is computed as:<br>
			<code>triangle_color × coverage + background_color × (1 - coverage)</code>
			</li>
		</ol>

		<p>This results in smooth gradients along triangle edges, replacing harsh digital transitions with more analog-like behavior.</p>

		<h2>Screenshots and Analysis</h2>

		<h3>Expected Results</h3>
		<ul>
			<li><strong>Sample Rate 1:</strong> Jagged edges with harsh black and white transitions.</li>
			<li><strong>Sample Rate 4:</strong> Noticeably smoother edges with intermediate grayscale pixels.</li>
			<li><strong>Sample Rate 16:</strong> Very smooth edges with continuous color blending and clean gradients.</li>
		</ul>

		<h3>Why These Results Occur</h3>
		<ul>
			<li>Higher sampling densities capture more precise information about where triangle edges intersect pixel boundaries.</li>
			<li>The averaging process transforms sharp binary edges into gradual transitions, visually similar to analog output.</li>
			<li>Sub-pixel precision enables accurate rendering of triangle features that are smaller than a single pixel.</li>
		</ul>

		<p>Thin triangle corners exhibit the highest aliasing in single-sample mode, and therefore benefit the most from supersampling. This makes them ideal for visual comparison of the antialiasing effect.</p>

		<h2>Remaining Tasks Preview</h2>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Task 3: Custom robot transformation (placeholder)</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Task 4: Barycentric coordinates demonstration (placeholder)</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.


		<h2>Task 4: Barycentric coordinates</h2>
		Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a svg file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.
		Show a png screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.


		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>