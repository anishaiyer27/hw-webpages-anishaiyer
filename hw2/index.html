<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: Anish Aiyer</div>

		<br>

		Link to webpage: <a href="https://anishaiyer.github.io/cs184/hw2/">https://anishaiyer.github.io/cs184/hw2/</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/anishaiyer/cs184-homework">https://github.com/anishaiyer/cs184-homework</a>

		<figure>
			<img src="teapot.png" alt="Sample mesh rendering" style="width:50%"/>
			<figcaption>Sample mesh rendering - replace with your own results</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		In this homework, I implemented geometric algorithms for working with Bezier curves and surfaces, as well as mesh manipulation techniques using the half-edge data structure. The first section focused on de Casteljau's algorithm for evaluating Bezier curves and extending it to Bezier surfaces through separable 1D subdivision. The second section involved implementing operations on triangle meshes, including computing area-weighted vertex normals for smooth shading, edge flip and split operations for mesh topology modification, and Loop subdivision for mesh upsampling. This homework provided deep insights into fundamental computational geometry concepts and their practical applications in computer graphics, particularly how mathematical constructs like Bezier curves translate into smooth surfaces and how mesh operations enable sophisticated 3D modeling workflows.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		<p><strong>Briefly explain de Casteljau's algorithm and how you implemented it:</strong></p>
		<p>De Casteljau's algorithm is a recursive method for evaluating Bezier curves at any parameter value t. The algorithm works by repeatedly performing linear interpolation between consecutive control points, reducing the number of points by one at each level until a single point remains on the curve.</p>

		<p>My implementation takes a set of control points and a parameter t, then computes the intermediate points by linear interpolation: for each pair of consecutive points, I calculate (1-t) * p_i + t * p_{i+1}. This process continues recursively until only one point remains, which is the point on the Bezier curve at parameter t.</p>

		<p>The beauty of this algorithm lies in its geometric interpretation - each level of subdivision represents a geometric construction that visually demonstrates how the curve is formed from its control polygon.</p>

		<p><strong>Screenshots of each step/level of evaluation (using a 6-control-point Bezier curve):</strong></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="bezier_step_0.png" width="400px"/>
				  <figcaption>Step 0: Original control points</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bezier_step_1.png" width="400px"/>
				  <figcaption>Step 1: First level of subdivision</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="bezier_step_2.png" width="400px"/>
				  <figcaption>Step 2: Second level of subdivision</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bezier_step_3.png" width="400px"/>
				  <figcaption>Step 3: Third level of subdivision</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="bezier_step_4.png" width="400px"/>
				  <figcaption>Step 4: Fourth level of subdivision</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bezier_final.png" width="400px"/>
				  <figcaption>Final: Evaluated point and completed curve</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p><strong>Screenshot of a slightly different Bezier curve with modified control points and parameter t:</strong></p>
		<figure>
			<img src="bezier_modified.png" alt="Modified Bezier curve" style="width:70%"/>
			<figcaption>Bezier curve with moved control points and different t parameter</figcaption>
		</figure>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		<p><strong>Briefly explain how de Casteljau algorithm extends to Bezier surfaces:</strong></p>
		<p>Bezier surfaces extend the concept of Bezier curves to two dimensions using a tensor product approach. A Bezier surface is defined by a grid of control points and evaluated using two parameters u and v.</p>

		<p>My implementation uses separable 1D de Casteljau subdivision, which means I first apply de Casteljau's algorithm along one parametric direction (say u) for each row of control points, then apply it again along the other direction (v) using the results from the first step. This approach reduces the 2D surface evaluation problem to multiple 1D curve evaluations.</p>

		<p>The process involves: 1) For each row of the control point grid, use de Casteljau with parameter u to get intermediate points, 2) Collect these intermediate points to form a new curve, 3) Apply de Casteljau again with parameter v to this new curve to get the final surface point. This separable approach is both computationally efficient and conceptually clear.</p>

		<p><strong>Screenshot of bez/teapot.bez evaluated by your implementation:</strong></p>
		<figure>
			<img src="teapot_bezier.png" alt="Teapot Bezier surface" style="width:70%"/>
			<figcaption>Teapot rendered using Bezier surface evaluation</figcaption>
		</figure>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		<p><strong>Briefly explain how you implemented the area-weighted vertex normals:</strong></p>
		<p>Area-weighted vertex normals provide smooth shading for triangle meshes by computing a normal vector at each vertex that represents the average orientation of all adjacent faces, weighted by their areas.</p>

		<p>My implementation iterates through all faces incident to a vertex using the half-edge data structure. For each face, I compute the face normal using the cross product of two edge vectors, and the face area using half the magnitude of this cross product. The vertex normal is then the sum of all face normals weighted by their respective areas, normalized to unit length.</p>

		<p>This approach produces visually pleasing smooth shading because larger faces have more influence on the vertex normal, which better represents the local surface geometry. The area weighting prevents small triangles from having disproportionate influence on the shading, resulting in more natural-looking surfaces.</p>

		<p><strong>Screenshots of dae/teapot.dae comparing teapot shading with and without vertex normals:</strong></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot_flat.png" width="400px"/>
				  <figcaption>Teapot with flat shading (without vertex normals)</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot_smooth.png" width="400px"/>
				  <figcaption>Teapot with Phong shading (with vertex normals)</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		<p><strong>Briefly explain how you implemented the edge flip operation:</strong></p>
		<p>Edge flip is a fundamental mesh operation that changes the local topology by "flipping" an edge between two adjacent triangles. Given an edge connecting two vertices, the flip operation removes this edge and creates a new edge connecting the two vertices that were previously unconnected.</p>

		<p>My implementation uses the half-edge data structure to carefully reassign all the pointers involved in the operation. The key is to identify all the mesh elements (vertices, edges, faces, half-edges) that will be affected and systematically update their connectivity. I first collect all the relevant mesh elements, then reassign the half-edge pointers to reflect the new topology after the flip.</p>

		<p>This operation is crucial for mesh processing algorithms and maintains the manifold property of the mesh while allowing local topology changes. It's particularly useful in mesh optimization and subdivision algorithms.</p>

		<p><strong>Screenshots of the teapot before and after some edge flips:</strong></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot_before_flips.png" width="400px"/>
				  <figcaption>Teapot before edge flips</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot_after_flips.png" width="400px"/>
				  <figcaption>Teapot after edge flips</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p><strong>Debugging journey:</strong></p>
		<p>The main challenge in implementing edge flip was ensuring all half-edge pointers were correctly updated. I found it helpful to draw diagrams of the before and after states, carefully tracking each half-edge and its relationships. A systematic approach of collecting all relevant elements first, then updating them in a specific order, helped avoid pointer corruption issues.</p>

		<h3>Part 5: Edge split</h3>
		<p><strong>Briefly explain how you implemented the edge split operation:</strong></p>
		<p>Edge split is another fundamental mesh operation that inserts a new vertex at the midpoint of an edge and creates new triangles to maintain a valid triangulation. This operation increases the mesh resolution locally while preserving the overall shape.</p>

		<p>My implementation creates a new vertex at the edge midpoint and adds the necessary new edges and faces. Using the half-edge data structure, I carefully manage all the pointer updates: the original edge is replaced by two new edges connecting to the new vertex, and the two adjacent triangles are each split into two new triangles. This requires creating new half-edges and updating all the connectivity information.</p>

		<p>Edge split is essential for adaptive mesh refinement and is a key component in subdivision algorithms. Unlike edge flip, this operation increases the number of vertices and faces in the mesh, allowing for higher geometric detail.</p>

		<p><strong>Screenshots of a mesh before and after some edge splits:</strong></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="mesh_before_splits.png" width="400px"/>
				  <figcaption>Mesh before edge splits</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="mesh_after_splits.png" width="400px"/>
				  <figcaption>Mesh after edge splits</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p><strong>Screenshots of a mesh before and after combination of edge splits and flips:</strong></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="mesh_original.png" width="400px"/>
				  <figcaption>Original mesh</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="mesh_splits_and_flips.png" width="400px"/>
				  <figcaption>After combination of splits and flips</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p><strong>Debugging journey:</strong></p>
		<p>Edge split was more complex than edge flip due to the need to create new mesh elements. The key insight was to systematically create all new elements first, then update the connectivity. I found it crucial to maintain consistency in the half-edge relationships and ensure boundary conditions were handled properly.</p>

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		<p><strong>Briefly explain how you implemented loop subdivision:</strong></p>
		<p>Loop subdivision is a surface subdivision scheme that creates smoother, higher-resolution meshes through repeated refinement. The algorithm combines topology refinement (splitting every triangle into four) with geometric smoothing using weighted averages of neighboring vertices.</p>

		<p>My implementation follows the Loop subdivision rules: 1) Compute new positions for existing vertices using a weighted average of neighboring vertices, 2) Compute positions for new vertices that will be inserted at edge midpoints, 3) Split every edge to insert new vertices, 4) Flip certain edges to achieve the correct connectivity pattern. The weights are carefully chosen to ensure the limiting surface has desirable smoothness properties.</p>

		<p>The beauty of Loop subdivision lies in its ability to create smooth surfaces from coarse triangle meshes. Each subdivision step quadruples the number of triangles while bringing the mesh closer to a smooth limiting surface. This makes it invaluable for creating high-quality models from simple base meshes.</p>

		<p><strong>Observations on how meshes behave after loop subdivision:</strong></p>
		<p>After loop subdivision, sharp corners and edges tend to become rounded and smooth. This is because the subdivision algorithm averages vertex positions with their neighbors, which has a smoothing effect. Sharp features can be preserved to some extent by pre-splitting edges around those features, which gives them more "weight" in the averaging process.</p>

		<p><strong>Loop subdivision on dae/cube.dae and asymmetry effects:</strong></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="cube_original.png" width="300px"/>
				  <figcaption>Original cube</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cube_subdivision_1.png" width="300px"/>
				  <figcaption>After 1 subdivision</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cube_subdivision_2.png" width="300px"/>
				  <figcaption>After 2 subdivisions</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="cube_subdivision_3.png" width="300px"/>
				  <figcaption>After 3 subdivisions</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cube_preprocessed.png" width="300px"/>
				  <figcaption>Pre-processed cube</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cube_symmetric.png" width="300px"/>
				  <figcaption>Symmetric subdivision result</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p><strong>Explanation of asymmetry and pre-processing solution:</strong></p>
		<p>The cube becomes asymmetric after repeated subdivisions because the original cube mesh has irregular connectivity - each face is split diagonally, creating triangles with different orientations. This asymmetric initial triangulation leads to uneven smoothing during subdivision.</p>

		<p>Pre-processing the cube by splitting edges to create a more symmetric triangulation helps alleviate this effect. By ensuring each face has consistent triangle orientation and adding edge splits to create more uniform connectivity, the subdivision process treats all regions of the cube more equally, resulting in a more symmetric final result.</p>

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		<p>For the art competition, I explored creative applications of the mesh editing techniques implemented in this homework. Using combinations of Loop subdivision, edge flips, and edge splits, I created artistic geometric forms that showcase both the technical capabilities and aesthetic potential of these algorithms.</p>

		<p>The creative modeling process involved starting with simple base meshes and applying various subdivision and editing operations to achieve interesting geometric patterns and smooth organic shapes. This section demonstrates how fundamental mesh operations can be combined in creative ways to produce compelling 3D art.</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="art_original.png" width="300px"/>
				  <figcaption>Original artistic mesh</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="art_subdivision_1.png" width="300px"/>
				  <figcaption>After 1 subdivision</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="art_subdivision_2.png" width="300px"/>
				  <figcaption>After 2 subdivisions</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p><strong>Description of creative enhancements:</strong></p>
		<p>I created a series of interconnected geometric shapes, including a twisted torus and a series of organic forms that resemble natural structures. By experimenting with different subdivision levels and incorporating edge flips, I was able to achieve a high degree of detail and visual interest in the final models.</p>
		</div>
	</body>
</html>